package com.$18_Gather;
/*
    泛型:
        是 JDK5 引入的特性, 可以在编译阶段约束操作的数据类型, 并进行检查
        格式: <数据类型>
        注意:
            1. 泛型只支持引用数据类型
            2. 指定泛型的具体类型后, 传递数据时, 可以传入该类类型或者其子类类型
            3. 如果不写泛型, 类型默认是Object
        优点:
            1. 统一数据类型
            2. 把运行时期的问题提前到了编译期间, 避免了强制转换类型可能出现的异常
        泛型类:
            使用场景: 当一个类中, 某个变量的数据类型不确定时, 就可以定义带有泛型的类
            定义格式:
                修饰符 class 类名<数据类型> {}
                例: public class ArrayList<E> {} ==> 创建该类对象后, 指定泛型, 才可以确定 E 的类型
                此处 E 可以理解为变量, 但是不是用来记录数据的, 而是记录数据的类型, 可以写成:T, E, K, V等
        泛型方法:
            方法中形参类型不确定时:
                方案一: 使用类名后定义的泛型
                方案二: 在方法申明上定义自己的泛型
            泛型方法定义格式:
                修饰符 <类型>返回值类型 方法名(类型 变量名) {}
                例: public <T>void show(T t) {} ==> 定义该方法, 在调用方法时, 才可以确定 T 的类型
                此处 T 可以理解为变量, 但是不是用来记录数据的, 而是记录数据的类型, 可以写成:T, E, K, V等
        泛型接口:
            定义格式: 修饰符 interface 接口名<类型> {}
            例: public interface List<E> {}
            带泛型接口的使用:
                1. 实现类给出具体类型
                2. 实现类延续泛型, 创建对象时再确定
        泛型的继承:
            泛型不具备继承性, 但是数据具备继承性
        泛型通配符:
            ?: 与 E, K, T, V一样, 表示不确定的类型, 可以对泛型的数据类型进行限定
            第一种: ? extends E: 表示可以传递 类型 E 或者 类型 E 所有的子类类型的数据
            第二种: ? super E: 表示可以传递 类型 E 或者 类型 E 所有的父类类型的数据(直接父类或父类的父类)
*/
public class $4_Genericity {
}
